<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SNFT 5-Digit Number Experiments</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border-radius: 10px;
        }
        
        h1 {
            font-size: 2.5rem;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .experiment-grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .control-panel {
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            color: #a78bfa;
            font-size: 0.9rem;
        }
        
        input, select, button {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            color: #e0e0e0;
            margin-bottom: 5px;
        }
        
        button {
            background: linear-gradient(45deg, #8a2be2, #4169e1);
            border: none;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(138, 43, 226, 0.4);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .visualization-area {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 10px;
            padding: 20px;
            min-height: 600px;
        }
        
        .chart-container {
            width: 100%;
            height: 500px;
            margin-bottom: 20px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .results-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .metric-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .metric-label {
            font-size: 0.9rem;
            color: #888;
            margin-top: 5px;
        }
        
        .log-area {
            background: #000;
            border: 1px solid #333;
            border-radius: 5px;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.8rem;
            margin-top: 10px;
        }
        
        .log-entry {
            margin: 2px 0;
            padding: 2px 5px;
        }
        
        .log-info { color: #4169e1; }
        .log-success { color: #00ff00; }
        .log-warning { color: #ffff00; }
        .log-error { color: #ff0000; }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tab.active {
            background: linear-gradient(45deg, #8a2be2, #4169e1);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .discovery-alert {
            background: linear-gradient(45deg, #ff6b6b, #ffd700);
            color: #000;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            font-weight: bold;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }
        
        .pattern-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        
        .pattern-table th, .pattern-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .pattern-table th {
            background: rgba(255, 255, 255, 0.1);
            font-weight: bold;
        }
        
        .download-section {
            margin-top: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>SNFT 5-Digit Experimental Framework</h1>
        <p>Systematic exploration of 10000-99999 number space</p>
    </div>
    
    <div class="experiment-grid">
        <div class="control-panel">
            <h2>ðŸ”¬ Experiment Controls</h2>
            
            <div class="control-group">
                <label>Range Start</label>
                <input type="number" id="rangeStart" value="10000" min="10000" max="99999">
            </div>
            
            <div class="control-group">
                <label>Range End</label>
                <input type="number" id="rangeEnd" value="11000" min="10000" max="99999">
            </div>
            
            <div class="control-group">
                <label>Sample Strategy</label>
                <select id="sampleStrategy">
                    <option value="all">All Numbers</option>
                    <option value="random">Random Sample</option>
                    <option value="resonance">Resonance Focus</option>
                    <option value="systematic">Systematic (every Nth)</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Sample Size</label>
                <input type="number" id="sampleSize" value="1000" min="100" max="10000">
            </div>
            
            <div class="control-group">
                <label>Transformation Rule</label>
                <select id="transformRule">
                    <option value="standard5">5-Digit Standard (1000a + d)</option>
                    <option value="extended5">Extended (100a + 10b + d)</option>
                    <option value="resonance27">27-Resonance</option>
                    <option value="cubic5">5-Digit Cubic Enhanced</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Max Steps</label>
                <input type="number" id="maxSteps" value="100" min="50" max="500">
            </div>
            
            <div class="control-group">
                <label>Focus Patterns (comma-separated)</label>
                <input type="text" id="focusPatterns" value="27,127,270,2718,3141" placeholder="27,36,45">
            </div>
            
            <button onclick="startExperiment()" id="startBtn">Start Experiment</button>
            <button onclick="pauseExperiment()" id="pauseBtn" disabled>Pause</button>
            <button onclick="exportResults()" id="exportBtn" disabled>Export Results</button>
            
            <div class="progress-bar">
                <div class="progress-fill" id="progressBar" style="width: 0%">0%</div>
            </div>
            
            <div class="log-area" id="logArea"></div>
        </div>
        
        <div class="visualization-area">
            <div class="tabs">
                <div class="tab active" onclick="switchTab('overview')">Overview</div>
                <div class="tab" onclick="switchTab('patterns')">Pattern Analysis</div>
                <div class="tab" onclick="switchTab('comparisons')">4D vs 5D</div>
                <div class="tab" onclick="switchTab('discoveries')">Discoveries</div>
            </div>
            
            <div id="overview" class="tab-content active">
                <div class="chart-container" id="convergenceScatter"></div>
                <div class="chart-container" id="attractorDistribution"></div>
            </div>
            
            <div id="patterns" class="tab-content">
                <div class="chart-container" id="patternHeatmap"></div>
                <div class="chart-container" id="resonanceComparison"></div>
            </div>
            
            <div id="comparisons" class="tab-content">
                <div class="chart-container" id="dimensionComparison"></div>
                <div class="results-panel">
                    <h3>Key Differences: 4-Digit vs 5-Digit</h3>
                    <div id="comparisonMetrics" class="metric-grid"></div>
                </div>
            </div>
            
            <div id="discoveries" class="tab-content">
                <div id="discoveryAlerts"></div>
                <table class="pattern-table" id="discoveryTable">
                    <thead>
                        <tr>
                            <th>Pattern</th>
                            <th>Count</th>
                            <th>Avg Steps</th>
                            <th>Efficiency</th>
                            <th>Primary Attractor</th>
                        </tr>
                    </thead>
                    <tbody id="discoveryBody"></tbody>
                </table>
            </div>
        </div>
    </div>
    
    <div class="results-panel">
        <h2>ðŸ“Š Experiment Summary</h2>
        <div class="metric-grid" id="summaryMetrics">
            <div class="metric-card">
                <div class="metric-value" id="totalProcessed">0</div>
                <div class="metric-label">Numbers Processed</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="avgConvergence">-</div>
                <div class="metric-label">Avg Convergence</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="newPatterns">0</div>
                <div class="metric-label">New Patterns Found</div>
            </div>
            <div class="metric-card">
                <div class="metric-value" id="anomalies">0</div>
                <div class="metric-label">Anomalies</div>
            </div>
        </div>
        
        <div class="download-section">
            <h3>ðŸ“¥ Export Options</h3>
            <button onclick="downloadCSV()">Download CSV</button>
            <button onclick="downloadJSON()">Download JSON</button>
            <button onclick="generateReport()">Generate LaTeX Report</button>
        </div>
    </div>
    
    <script>
        // Global state
        let experimentData = [];
        let isRunning = false;
        let isPaused = false;
        let currentIndex = 0;
        let discoveries = new Map();
        let patternStats = new Map();
        
        // Transformation functions for 5-digit numbers
        function transform5Digit(n, rule, step = 0) {
            const str = n.toString();
            if (str.length !== 5) return n; // Safety check
            
            const digits = str.split('').map(Number);
            const [a, b, c, d, e] = digits;
            const sum = digits.reduce((acc, d) => acc + d, 0);
            
            switch(rule) {
                case 'standard5':
                    return n - (1000 * a + e);
                    
                case 'extended5':
                    return n - (100 * a + 10 * b + e);
                    
                case 'resonance27':
                    if (str.includes('27')) {
                        return Math.floor((n - 27) / 3);
                    }
                    return n - (sum % 27);
                    
                case 'cubic5':
                    if (step === 4) {
                        return n - (Math.pow(a, 3) + Math.pow(e, 3));
                    }
                    return n - (1000 * a + e);
                    
                default:
                    return n - (1000 * a + e);
            }
        }
        
        function tracePath5D(n, rule, maxSteps) {
            const path = [n];
            let current = n;
            
            for (let step = 0; step < maxSteps; step++) {
                if (current < 10000) {
                    // Dropped below 5 digits
                    break;
                }
                
                current = transform5Digit(current, rule, step);
                path.push(current);
                
                // Check for convergence
                if (path.length > 2 && current === path[path.length - 2]) {
                    break;
                }
                
                // Check for cycles
                if (path.length > 5) {
                    for (let cycleLen = 2; cycleLen <= 5; cycleLen++) {
                        if (path.length >= cycleLen * 2) {
                            let isCycle = true;
                            for (let i = 0; i < cycleLen; i++) {
                                if (path[path.length - 1 - i] !== path[path.length - 1 - i - cycleLen]) {
                                    isCycle = false;
                                    break;
                                }
                            }
                            if (isCycle) {
                                return { path, cycleLength: cycleLen };
                            }
                        }
                    }
                }
            }
            
            return { path, cycleLength: 0 };
        }
        
        function analyzeNumber(n, rule, maxSteps) {
            const { path, cycleLength } = tracePath5D(n, rule, maxSteps);
            const str = n.toString();
            const digits = str.split('').map(Number);
            
            // Calculate metrics
            const steps = path.length - 1;
            const finalValue = path[path.length - 1];
            const attractor = cycleLength > 0 ? `cycle-${cycleLength}` : finalValue;
            
            // Calculate deltas
            const deltas = [];
            for (let i = 1; i < path.length; i++) {
                deltas.push(Math.abs(path[i] - path[i-1]));
            }
            
            const avgDelta = deltas.reduce((a, b) => a + b, 0) / deltas.length || 0;
            const variance = deltas.reduce((acc, d) => acc + Math.pow(d - avgDelta, 2), 0) / deltas.length || 0;
            const stdDelta = Math.sqrt(variance);
            const efficiency = avgDelta / (stdDelta + 1);
            
            // Pattern detection
            const patterns = detectPatterns(str);
            
            return {
                number: n,
                path,
                steps,
                attractor,
                avgDelta,
                stdDelta,
                efficiency,
                patterns,
                cycleLength,
                digitSum: digits.reduce((a, b) => a + b, 0),
                firstDigit: digits[0],
                lastDigit: digits[4],
                contains27: str.includes('27'),
                contains127: str.includes('127'),
                contains270: str.includes('270'),
                contains2718: str.includes('2718'),
                contains3141: str.includes('3141')
            };
        }
        
        function detectPatterns(str) {
            const patterns = [];
            
            // Check for known resonance patterns
            const resonancePatterns = ['27', '36', '45', '54', '63', '72', '81', '90', '127', '270', '2718', '3141'];
            for (const pattern of resonancePatterns) {
                if (str.includes(pattern)) {
                    patterns.push(pattern);
                }
            }
            
            // Check for palindromes
            if (str === str.split('').reverse().join('')) {
                patterns.push('palindrome');
            }
            
            // Check for repeating digits
            const digits = str.split('');
            if (new Set(digits).size < digits.length) {
                patterns.push('repeating');
            }
            
            // Check for arithmetic sequences
            let isArithmetic = true;
            const diff = parseInt(digits[1]) - parseInt(digits[0]);
            for (let i = 2; i < digits.length; i++) {
                if (parseInt(digits[i]) - parseInt(digits[i-1]) !== diff) {
                    isArithmetic = false;
                    break;
                }
            }
            if (isArithmetic) {
                patterns.push('arithmetic');
            }
            
            return patterns;
        }
        
        async function startExperiment() {
            if (isRunning) return;
            
            isRunning = true;
            isPaused = false;
            experimentData = [];
            discoveries.clear();
            patternStats.clear();
            
            const rangeStart = parseInt(document.getElementById('rangeStart').value);
            const rangeEnd = parseInt(document.getElementById('rangeEnd').value);
            const sampleStrategy = document.getElementById('sampleStrategy').value;
            const sampleSize = parseInt(document.getElementById('sampleSize').value);
            const rule = document.getElementById('transformRule').value;
            const maxSteps = parseInt(document.getElementById('maxSteps').value);
            
            // Generate sample numbers
            const numbers = generateSample(rangeStart, rangeEnd, sampleStrategy, sampleSize);
            
            log('info', `Starting experiment with ${numbers.length} numbers`);
            log('info', `Range: ${rangeStart}-${rangeEnd}, Rule: ${rule}`);
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('exportBtn').disabled = true;
            
            // Process numbers
            for (let i = 0; i < numbers.length; i++) {
                if (!isRunning || isPaused) break;
                
                const n = numbers[i];
                const result = analyzeNumber(n, rule, maxSteps);
                experimentData.push(result);
                
                // Update pattern statistics
                for (const pattern of result.patterns) {
                    if (!patternStats.has(pattern)) {
                        patternStats.set(pattern, {
                            count: 0,
                            totalSteps: 0,
                            totalEfficiency: 0,
                            attractors: new Map()
                        });
                    }
                    
                    const stats = patternStats.get(pattern);
                    stats.count++;
                    stats.totalSteps += result.steps;
                    stats.totalEfficiency += result.efficiency;
                    
                    if (!stats.attractors.has(result.attractor)) {
                        stats.attractors.set(result.attractor, 0);
                    }
                    stats.attractors.set(result.attractor, stats.attractors.get(result.attractor) + 1);
                }
                
                // Check for discoveries
                checkForDiscoveries(result);
                
                // Update progress
                const progress = ((i + 1) / numbers.length * 100).toFixed(1);
                updateProgress(progress);
                
                // Update visualizations periodically
                if (i % 100 === 0 || i === numbers.length - 1) {
                    await updateVisualizations();
                    await new Promise(resolve => setTimeout(resolve, 10)); // Allow UI to update
                }
            }
            
            isRunning = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('exportBtn').disabled = false;
            
            log('success', 'Experiment completed!');
            showFinalResults();
        }
        
        function generateSample(start, end, strategy, size) {
            const numbers = [];
            
            switch(strategy) {
                case 'all':
                    for (let i = start; i <= end && i < start + size; i++) {
                        numbers.push(i);
                    }
                    break;
                    
                case 'random':
                    const available = end - start + 1;
                    const actualSize = Math.min(size, available);
                    const selected = new Set();
                    while (selected.size < actualSize) {
                        selected.add(Math.floor(Math.random() * available) + start);
                    }
                    numbers.push(...selected);
                    break;
                    
                case 'resonance':
                    // Focus on numbers containing known patterns
                    const patterns = document.getElementById('focusPatterns').value.split(',').map(p => p.trim());
                    for (let i = start; i <= end && numbers.length < size; i++) {
                        const str = i.toString();
                        if (patterns.some(p => str.includes(p))) {
                            numbers.push(i);
                        }
                    }
                    // Fill remaining with random
                    while (numbers.length < size && numbers.length < end - start + 1) {
                        const n = Math.floor(Math.random() * (end - start + 1)) + start;
                        if (!numbers.includes(n)) {
                            numbers.push(n);
                        }
                    }
                    break;
                    
                case 'systematic':
                    const step = Math.floor((end - start) / size);
                    for (let i = start; i <= end && numbers.length < size; i += step) {
                        numbers.push(i);
                    }
                    break;
            }
            
            return numbers.sort((a, b) => a - b);
        }
        
        function checkForDiscoveries(result) {
            // Check for unusually fast convergence
            if (result.steps < 10 && result.number > 50000) {
                log('warning', `Fast convergence: ${result.number} â†’ ${result.attractor} in ${result.steps} steps`);
                addDiscovery('fast_convergence', result);
            }
            
            // Check for new attractors
            const knownAttractors = [0, 90, 900, 930, 970, 9000, 9300, 9700];
            if (!knownAttractors.includes(result.attractor) && !result.attractor.toString().startsWith('cycle')) {
                log('error', `New attractor found: ${result.attractor} (from ${result.number})`);
                addDiscovery('new_attractor', result);
            }
            
            // Check for super-efficient paths
            if (result.efficiency > 10) {
                log('success', `Super-efficient path: ${result.number} with efficiency ${result.efficiency.toFixed(2)}`);
                addDiscovery('high_efficiency', result);
            }
            
            // Check for long cycles
            if (result.cycleLength > 3) {
                log('warning', `Long cycle found: ${result.number} has cycle length ${result.cycleLength}`);
                addDiscovery('long_cycle', result);
            }
        }
        
        function addDiscovery(type, result) {
            if (!discoveries.has(type)) {
                discoveries.set(type, []);
            }
            discoveries.get(type).push(result);
            
            // Update discovery count
            document.getElementById('newPatterns').textContent = discoveries.size;
            document.getElementById('anomalies').textContent = 
                Array.from(discoveries.values()).reduce((sum, arr) => sum + arr.length, 0);
        }
        
        function updateProgress(percent) {
            const bar = document.getElementById('progressBar');
            bar.style.width = percent + '%';
            bar.textContent = percent + '%';
        }
        
        function log(type, message) {
            const logArea = document.getElementById('logArea');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        }
        
        async function updateVisualizations() {
            const processed = experimentData.length;
            document.getElementById('totalProcessed').textContent = processed;
            
            if (processed === 0) return;
            
            // Calculate summary metrics
            const avgSteps = experimentData.reduce((sum, d) => sum + d.steps, 0) / processed;
            document.getElementById('avgConvergence').textContent = avgSteps.toFixed(2);
            
            // Update active tab visualization
            const activeTab = document.querySelector('.tab-content.active').id;
            switch(activeTab) {
                case 'overview':
                    updateOverviewCharts();
                    break;
                case 'patterns':
                    updatePatternCharts();
                    break;
                case 'comparisons':
                    updateComparisonCharts();
                    break;
                case 'discoveries':
                    updateDiscoveryTable();
                    break;
            }
        }
        
        function updateOverviewCharts() {
            // Convergence scatter plot
            const scatterData = {
                x: experimentData.map(d => d.number),
                y: experimentData.map(d => d.steps),
                mode: 'markers',
                type: 'scatter',
                marker: {
                    size: 5,
                    color: experimentData.map(d => d.efficiency),
                    colorscale: 'Viridis',
                    showscale: true,
                    colorbar: {
                        title: 'Efficiency'
                    }
                },
                text: experimentData.map(d => 
                    `Number: ${d.number}<br>Steps: ${d.steps}<br>Attractor: ${d.attractor}<br>Patterns: ${d.patterns.join(', ')}`
                ),
                hoverinfo: 'text'
            };
            
            const scatterLayout = {
                title: 'Convergence Landscape (5-Digit Numbers)',
                xaxis: { title: 'Number' },
                yaxis: { title: 'Steps to Convergence' },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0.1)',
                font: { color: '#e0e0e0' }
            };
            
            Plotly.newPlot('convergenceScatter', [scatterData], scatterLayout, {responsive: true});
            
            // Attractor distribution
            const attractorCounts = {};
            experimentData.forEach(d => {
                attractorCounts[d.attractor] = (attractorCounts[d.attractor] || 0) + 1;
            });
            
            const attractorData = {
                labels: Object.keys(attractorCounts),
                values: Object.values(attractorCounts),
                type: 'pie',
                textinfo: 'label+percent',
                marker: {
                    colors: ['#8a2be2', '#4169e1', '#00ced1', '#32cd32', '#ff6347', '#ffd700']
                }
            };
            
            const attractorLayout = {
                title: 'Attractor Distribution',
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0)',
                font: { color: '#e0e0e0' }
            };
            
            Plotly.newPlot('attractorDistribution', [attractorData], attractorLayout, {responsive: true});
        }
        
        function updatePatternCharts() {
            // Pattern heatmap
            const patterns = Array.from(patternStats.keys()).slice(0, 10); // Top 10 patterns
            const heatmapData = patterns.map(pattern => {
                const stats = patternStats.get(pattern);
                return [
                    stats.count,
                    stats.totalSteps / stats.count,
                    stats.totalEfficiency / stats.count
                ];
            });
            
            const heatmapTrace = {
                z: heatmapData,
                x: ['Count', 'Avg Steps', 'Avg Efficiency'],
                y: patterns,
                type: 'heatmap',
                colorscale: 'Viridis'
            };
            
            const heatmapLayout = {
                title: 'Pattern Analysis Heatmap',
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0.1)',
                font: { color: '#e0e0e0' }
            };
            
            Plotly.newPlot('patternHeatmap', [heatmapTrace], heatmapLayout, {responsive: true});
            
            // Resonance comparison
            const resonanceData = patterns.map(pattern => {
                const stats = patternStats.get(pattern);
                return {
                    x: [pattern],
                    y: [stats.totalSteps / stats.count],
                    name: pattern,
                    type: 'bar'
                };
            });
            
            const resonanceLayout = {
                title: 'Average Steps by Pattern',
                xaxis: { title: 'Pattern' },
                yaxis: { title: 'Average Steps' },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0.1)',
                font: { color: '#e0e0e0' },
                showlegend: false
            };
            
            Plotly.newPlot('resonanceComparison', resonanceData, resonanceLayout, {responsive: true});
        }
        
        function updateComparisonCharts() {
            // This would compare with 4-digit data if available
            // For now, show digit position analysis
            const positionData = [1, 2, 3, 4, 5].map(pos => {
                const digitCounts = Array(10).fill(0);
                experimentData.forEach(d => {
                    const digit = d.number.toString()[pos - 1];
                    digitCounts[parseInt(digit)]++;
                });
                
                return {
                    y: digitCounts,
                    x: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],
                    name: `Position ${pos}`,
                    type: 'bar'
                };
            });
            
            const comparisonLayout = {
                title: 'Digit Distribution by Position',
                xaxis: { title: 'Digit Value' },
                yaxis: { title: 'Count' },
                paper_bgcolor: 'rgba(0,0,0,0)',
                plot_bgcolor: 'rgba(0,0,0,0.1)',
                font: { color: '#e0e0e0' },
                barmode: 'group'
            };
            
            Plotly.newPlot('dimensionComparison', positionData, comparisonLayout, {responsive: true});
            
            // Update comparison metrics
            const metricsDiv = document.getElementById('comparisonMetrics');
            metricsDiv.innerHTML = `
                <div class="metric-card">
                    <div class="metric-value">${experimentData.filter(d => d.contains27).length}</div>
                    <div class="metric-label">Contains '27'</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${experimentData.filter(d => d.contains127).length}</div>
                    <div class="metric-label">Contains '127'</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value">${experimentData.filter(d => d.contains2718).length}</div>
                    <div class="metric-label">Contains '2718'</div>
                </div>
            `;
        }
        
        function updateDiscoveryTable() {
            const tbody = document.getElementById('discoveryBody');
            tbody.innerHTML = '';
            
            patternStats.forEach((stats, pattern) => {
                const row = tbody.insertRow();
                row.innerHTML = `
                    <td>${pattern}</td>
                    <td>${stats.count}</td>
                    <td>${(stats.totalSteps / stats.count).toFixed(2)}</td>
                    <td>${(stats.totalEfficiency / stats.count).toFixed(2)}</td>
                    <td>${Array.from(stats.attractors.entries())
                        .sort((a, b) => b[1] - a[1])[0]?.[0] || 'N/A'}</td>
                `;
            });
            
            // Show discovery alerts
            const alertsDiv = document.getElementById('discoveryAlerts');
            alertsDiv.innerHTML = '';
            
            discoveries.forEach((results, type) => {
                if (results.length > 0) {
                    const alert = document.createElement('div');
                    alert.className = 'discovery-alert';
                    alert.textContent = `${type.replace('_', ' ').toUpperCase()}: ${results.length} instances found!`;
                    alertsDiv.appendChild(alert);
                }
            });
        }
        
        function showFinalResults() {
            // Generate comprehensive summary
            const summary = {
                totalNumbers: experimentData.length,
                avgSteps: experimentData.reduce((sum, d) => sum + d.steps, 0) / experimentData.length,
                avgEfficiency: experimentData.reduce((sum, d) => sum + d.efficiency, 0) / experimentData.length,
                uniqueAttractors: new Set(experimentData.map(d => d.attractor)).size,
                patternsFound: patternStats.size,
                discoveries: discoveries.size
            };
            
            log('success', `Experiment Summary:`);
            log('info', `- Total numbers analyzed: ${summary.totalNumbers}`);
            log('info', `- Average convergence steps: ${summary.avgSteps.toFixed(2)}`);
            log('info', `- Average efficiency: ${summary.avgEfficiency.toFixed(2)}`);
            log('info', `- Unique attractors: ${summary.uniqueAttractors}`);
            log('info', `- Pattern types found: ${summary.patternsFound}`);
            log('info', `- Discoveries made: ${summary.discoveries}`);
        }
        
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            
            updateVisualizations();
        }
        
        function pauseExperiment() {
            isPaused = !isPaused;
            document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause';
            log('info', isPaused ? 'Experiment paused' : 'Experiment resumed');
        }
        
        function downloadCSV() {
            const csv = Papa.unparse(experimentData.map(d => ({
                number: d.number,
                steps: d.steps,
                attractor: d.attractor,
                efficiency: d.efficiency,
                patterns: d.patterns.join(';'),
                firstDigit: d.firstDigit,
                lastDigit: d.lastDigit,
                digitSum: d.digitSum,
                contains27: d.contains27,
                contains127: d.contains127,
                avgDelta: d.avgDelta,
                stdDelta: d.stdDelta
            })));
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `snft_5digit_results_${Date.now()}.csv`;
            a.click();
        }
        
        function downloadJSON() {
            const json = JSON.stringify({
                metadata: {
                    date: new Date().toISOString(),
                    totalNumbers: experimentData.length,
                    rule: document.getElementById('transformRule').value,
                    range: [
                        document.getElementById('rangeStart').value,
                        document.getElementById('rangeEnd').value
                    ]
                },
                results: experimentData,
                patternStats: Object.fromEntries(patternStats),
                discoveries: Object.fromEntries(discoveries)
            }, null, 2);
            
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `snft_5digit_analysis_${Date.now()}.json`;
            a.click();
        }
        
        function generateReport() {
            // Generate LaTeX report content
            const report = `\\documentclass{article}
\\usepackage{graphicx}
\\usepackage{amsmath}
\\usepackage{booktabs}

\\title{SNFT 5-Digit Number Analysis Report}
\\author{Generated by SNFT Explorer}
\\date{${new Date().toLocaleDateString()}}

\\begin{document}
\\maketitle

\\section{Executive Summary}
Analysis of ${experimentData.length} five-digit numbers revealed:
\\begin{itemize}
    \\item Average convergence: ${(experimentData.reduce((sum, d) => sum + d.steps, 0) / experimentData.length).toFixed(2)} steps
    \\item ${patternStats.size} distinct patterns identified
    \\item ${discoveries.size} types of discoveries made
\\end{itemize}

\\section{Pattern Analysis}
\\begin{table}[h]
\\centering
\\begin{tabular}{lrrr}
\\toprule
Pattern & Count & Avg Steps & Efficiency \\\\
\\midrule
${Array.from(patternStats.entries()).slice(0, 10).map(([pattern, stats]) => 
    `${pattern} & ${stats.count} & ${(stats.totalSteps/stats.count).toFixed(2)} & ${(stats.totalEfficiency/stats.count).toFixed(2)}`
).join(' \\\\\n')} \\\\
\\bottomrule
\\end{tabular}
\\caption{Top 10 patterns by frequency}
\\end{table}

\\section{Discoveries}
${Array.from(discoveries.entries()).map(([type, results]) => 
    `\\subsection{${type.replace('_', ' ').charAt(0).toUpperCase() + type.replace('_', ' ').slice(1)}}
Found ${results.length} instances. Examples: ${results.slice(0, 3).map(r => r.number).join(', ')}`
).join('\n\n')}

\\end{document}`;
            
            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `snft_5digit_report_${Date.now()}.tex`;
            a.click();
        }
        
        function exportResults() {
            downloadCSV();
        }
    </script>
</body>
</html>